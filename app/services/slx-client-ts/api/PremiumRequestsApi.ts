/**
 * SalesLogix API
 * Allows to access SalesLogix information and reports Allows to access SalesLogix information and reports
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {Http, Headers, RequestOptionsArgs, Response, URLSearchParams} from '@angular/http';
import {Injectable, Optional} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import * as models from '../model/models';
import 'rxjs/Rx';

/* tslint:disable:no-unused-variable member-ordering */

'use strict';

@Injectable()
export class PremiumRequestsApi {
    protected basePath = 'http://northstar.nybblenetwork.com/slx-api/v1';
    public defaultHeaders : Headers = new Headers();

    constructor(protected http: Http, @Optional() basePath: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    /**
     * Add Premium Request
     * Create a new premium request with the corresponding documents and batches
     * @param body 
     */
    public addPremiumRequest (body?: models.Premiumrequestinput, extraHttpRequestParams?: any ) : Observable<models.PremiumRequest> {
        const path = this.basePath + '/premium-requests';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        let requestOptions: RequestOptionsArgs = {
            method: 'POST',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(body);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * CalculatePaymentDates
     * This API retrieve the payment dates of premium requests.
     * @param currentDate current_date to return
     * @param count number of counts
     * @param workableDays number of workable_days
     */
    public calculatePaymentDates (currentDate?: Date, count?: number, workableDays?: number, extraHttpRequestParams?: any ) : Observable<Array<Date>> {
        const path = this.basePath + '/premium-requests/payment-dates';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (currentDate !== undefined) {
            queryParameters.set('current_date', String(currentDate));
        }

        if (count !== undefined) {
            queryParameters.set('count', String(count));
        }

        if (workableDays !== undefined) {
            queryParameters.set('workable_days', String(workableDays));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List premium request batches by premium request Id
     * 
     * @param premiumRequestId 
     * @param state 
     */
    public gETPremiumRequestBatches (premiumRequestId?: string, state?: string, extraHttpRequestParams?: any ) : Observable<Array<models.PremiumRequestBatch>> {
        const path = this.basePath + '/premium-request-batches';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (premiumRequestId !== undefined) {
            queryParameters.set('premiumRequestId', String(premiumRequestId));
        }

        if (state !== undefined) {
            queryParameters.set('state', String(state));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List premium request policies by premium request id
     * 
     * @param id 
     */
    public gETPremiumRequestsIdPolicies (id: string, extraHttpRequestParams?: any ) : Observable<Array<models.PremiumRequestPolicy>> {
        const path = this.basePath + '/premium-requests/{id}/policies'
            .replace('{' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gETPremiumRequestsIdPolicies.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get Premium Request
     * This API retrieves a premium request.
     * @param id 
     * @param includePolicyDetail 
     */
    public getPremiumRequest (id: string, includePolicyDetail?: boolean, extraHttpRequestParams?: any ) : Observable<models.PremiumRequest> {
        const path = this.basePath + '/premium-requests/{id}'
            .replace('{' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPremiumRequest.');
        }
        if (includePolicyDetail !== undefined) {
            queryParameters.set('includePolicyDetail', String(includePolicyDetail));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List Premium Request Policies
     * 
     * @param status 
     * @param hasPayment Retrieves the policies that have a payment date or not already applied in thee current policy premium.
     */
    public listPremiumRequestPolicies (status?: string, hasPayment?: boolean, extraHttpRequestParams?: any ) : Observable<Array<models.PremiumRequestPolicy>> {
        const path = this.basePath + '/premium-requests/policies';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (status !== undefined) {
            queryParameters.set('status', String(status));
        }

        if (hasPayment !== undefined) {
            queryParameters.set('hasPayment', String(hasPayment));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update premium request policy by policy ID
     * 
     * @param policyId 
     * @param body 
     */
    public pUTPremiumRequestsPoliciesPolicyId (policyId: string, body?: models.PremiumRequestPolicy, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/premium-requests/policies/{policyId}'
            .replace('{' + 'policyId' + '}', String(policyId));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling pUTPremiumRequestsPoliciesPolicyId.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(body);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update Premium Request
     * This API updates a premium request.
     * @param id 
     * @param body 
     */
    public updatePremiumRequest (id: string, body?: models.Premiumrequestinput, extraHttpRequestParams?: any ) : Observable<models.PremiumRequest> {
        const path = this.basePath + '/premium-requests/{id}'
            .replace('{' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePremiumRequest.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(body);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update Premium Request Batch
     * Update the policy batch
     * @param id 
     * @param batchId 
     * @param body 
     */
    public updatePremiumRequestBatch (id: string, batchId: string, body?: models.PremiumRequestBatch, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/premium-requests/{id}/batchs/{batchId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'batchId' + '}', String(batchId));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePremiumRequestBatch.');
        }
        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling updatePremiumRequestBatch.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(body);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update Premium Request Policy
     * Update the policy batch
     * @param id 
     * @param policyId 
     * @param body 
     */
    public updatePremiumRequestPolicy (id: string, policyId: string, body?: models.PremiumRequestPolicy, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/premium-requests/{id}/policies/{policyId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'policyId' + '}', String(policyId));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePremiumRequestPolicy.');
        }
        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling updatePremiumRequestPolicy.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(body);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

}
